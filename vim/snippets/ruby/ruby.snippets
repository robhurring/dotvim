# encoding for Ruby 1.9
snippet enc
	# encoding: utf-8

# #!/usr/bin/env ruby
snippet #!
	#!/usr/bin/env ruby
	# encoding: utf-8

snippet prot
	protected

	${0}
snippet priv
	private

	${0}
snippet yield
	yield ${0:arguments}
snippet begin
	begin
		${0}
	rescue ${1:Exception} => ${2:e}
	end
snippet req require
	require '${1}'
snippet reqr
	require_relative '${1}'
snippet #
	# =>
snippet end
	__END__
	${0}
snippet case
	case ${1:object}
	when ${2:condition}
		${0}
	end
snippet when
	when ${1:condition}
		${0}
snippet def
	def ${1:method_name}
		${0}
	end
snippet deft
	def test_${1:case_name}
		${0}
	end
snippet if
	if ${1:condition}
		${0}
	end
snippet ife
	if ${1:condition}
		${2}
	else
		${0}
	end
snippet eif
	elsif ${1:condition}
		${0}
snippet ifee
	if ${1:condition}
		$2
	elsif ${3:condition}
		$4
	else
		$0
	end
snippet unless
	unless ${1:condition}
		${0}
	end
snippet while
	while ${1:condition}
		${0}
	end
snippet for
	for ${1:e} in ${2:c}
		${0}
	end
snippet until
	until ${1:condition}
		${0}
	end
snippet cla "class .. end"
	class ${1:Klass}
		${0}
	end
snippet cla "class .. initialize .. end"
	class ${1:Klass}
		def initialize(${2:args})
			${0}
		end
	end
snippet cla< "class .. < ParentClass .. initialize .. end"
	class ${1:Klass} < ${2:ParentClass}
		def initialize(${3:args})
			${0}
		end
	end
snippet blankslate class BlankSlate .. initialize .. end
	class ${0:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
	end
snippet claself class << self .. end
	class << ${1:self}
		${0}
	end
snippet mod module .. end
	module ${1:Concern}
		${0}
	end
snippet mod module .. ClassMethods .. end
	module ${1:Concern}
		def self.included(base)
			base.extend ClassMethods
		end

		module ClassMethods
			${0}
		end
	end
snippet concern "ActiveSupport::Concern"
	module ${1:Concern}
		extend ActiveSupport::Concern

		included do
			${1}
		end

		module ClassMethods
			${2}
		end
		${0}
	end
# attr_reader
snippet r
	attr_reader :${0:attr_names}
# attr_writer
snippet w
	attr_writer :${0:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${0:attr_names}
snippet atp
	attr_protected :${0:attr_names}
snippet ata
	attr_accessible :${0:attr_names}
snippet ivc "instance variable cache"
	@_${1:variable_name} ||= ${0:cached_value}
snippet Enum
	include Enumerable

	def each(&block)
		${0}
	end
# include Comparable
snippet Comp
	include Comparable

	def <=>(other)
		${0}
	end
# extend Forwardable
snippet Forw-
	extend Forwardable
# def self
snippet defs
	def self.${1:class_method_name}
		${0}
	end
# def initialize
snippet definit
	def initialize(${1:args})
		${0}
	end
# def method_missing
snippet defmm
	def method_missing(meth, *args, &blk)
		${0}
	end
snippet defd
	def_delegator :${1:@del_obj}, :${2:del_meth}, :${0:new_name}
snippet defds
	def_delegators :${1:@del_obj}, :${0:del_methods}
snippet am
	alias_method :${1:new_name}, :${0:old_name}
snippet app
	if __FILE__ == $PROGRAM_NAME
		${0}
	end
snippet array
	Array.new(${1:10}) { |${2:i}| ${0} }
snippet hash
	Hash.new { |${1:hash}, ${2:key}| $1[$2] = ${0} }
snippet file File.foreach() { |line| .. }
	File.foreach(${1:'path/to/file'}) { |${2:line}| ${0} }
snippet file File.read()
	File.read(${1:'path/to/file'})
snippet Dir Dir.global() { |file| .. }
	Dir.glob(${1:'dir/glob/*'}) { |${2:file}| ${0} }
snippet Dir Dir[".."]
	Dir[${1:'glob/**/*.rb'}]
snippet dir
	Filename.dirname(__FILE__)
snippet deli
	delete_if { |${1:e}| ${0} }
snippet fil
	fill(${1:range}) { |${2:i}| ${0} }
# flatten_once()
snippet times
	times { |${1:n}| ${0} }
snippet upto
	upto(${1:1.0/0.0}) { |${2:n}| ${0} }
snippet ea
	each { |${1:e}| ${0} }
snippet ead
	each do |${1:e}|
		${0}
	end
snippet eawo
	each_with_object(${1:init}) { |${2:e}, ${3:var}| ${0} }
snippet eawod
	each_with_object(${1:init}) do |${2:e}, ${3:var}|
		${0}
	end
snippet red
	reduce(${1:init}) { |${2:mem}, ${3:var}| ${0} }
snippet redd
	reduce(${1:init}) do |${2:mem}, ${3:var}|
		${0}
	end
snippet map
	map { |${1:e}| ${0} }
snippet mapd
	map do |${1:e}|
		${0}
	end
snippet sor
	sort { |a, b| ${0} }
snippet sorb
	sort_by { |${1:e}| ${0} }
snippet ran
	sort_by { rand }
snippet all
	all? { |${1:e}| ${0} }
snippet any
	any? { |${1:e}| ${0} }
snippet det
	detect { |${1:e}| ${0} }
snippet detd
	detect do |${1:e}|
		${0}
	end
snippet fet
	fetch(${1:name}) { |${2:key}| ${0} }
snippet sub
	${1:g}sub(${2:/pattern/}) { |${3:match}| ${0} }
snippet max
	max { |a, b| ${0} }
snippet min
	min { |a, b| ${0} }
snippet rej
	reject { |${1:e}| ${0} }
snippet rejd
	reject do |${1:e}|
		${0}
	end
snippet sel
	select { |${1:e}| ${0} }
snippet seld
	select do |${1:e}|
		${0}
	end
snippet lam
	lambda { |${1:args}| ${0} }
snippet ->
	-> { ${0} }
snippet ->a
	->(${1:args}) { ${0} }
snippet do
	do
		${0}
	end
snippet dov
	do |${1:v}|
		${2}
	end
snippet :
	${1:key}: ${2:'value'}
snippet fpath
	File.join(File.dirname(__FILE__), *['${1:rel path here}'])
snippet optp
	require 'optparse'

	options = { ${0:default: 'args'} }

	ARGV.options do |opts|
		opts.banner = "Usage: #{File.basename($PROGRAM_NAME)}"
	end
snippet opt
	opts.on('-${1:o}', '--${2:long-option-name}', ${3:String}, '${4:Option description.}') do |${5:opt}|
		${0}
	end
snippet bm-
	TESTS = ${1:10_000}
	Benchmark.bmbm do |results|
		${0}
	end
snippet rep
	results.report('${1:name}:') { TESTS.times { ${0} } }
# Marshal.dump(.., file)
snippet sinc
	class << self; self end
snippet namespace
	namespace :${1} do
		${0}
	end
snippet task
	desc '${1:Task description}'
	task ${2:task_name: [:dependent, :tasks]} do
		${0}
	end
# block
snippet b
	{ |${1:var}| ${0} }
snippet debug
	require 'byebug'; byebug
snippet debug19
	require 'debugger'; debugger
snippet debug18
	require 'ruby-debug'; debugger
snippet pry
	require 'pry'; binding.pry
