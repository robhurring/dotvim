# --> Fn

snippet fn "Function definition"
fn ${1:function_name}(${2})${3} {
	${0}
}
endsnippet

snippet pfn "Function definition"
pub fn ${1:function_name}(${2})${3} {
	${0}
}
endsnippet

snippet test "Unit test function"
#[test]
fn ${1:test_function_name}() {
	${0}
}
endsnippet

# --> Lets

snippet let "let variable declaration with type inference"
let ${1} = ${2};
endsnippet

snippet lett "let variable declaration with explicit type annotation"
let ${1}: ${2}  = ${3};
endsnippet

snippet letm "let mut variable declaration with type inference"
let mut ${1}  = ${2};
endsnippet

snippet lettm "let mut variable declaration with explicit type annotation"
let mut ${1}: ${2}  = ${3};
endsnippet

snippet pln "println!"
println!("${1}");
endsnippet

snippet pln, "println! with format param"
println!("${1}", ${2});
endsnippet

# --> Attributes

snippet allow "allow lint attribute" b
#[allow(${1:unused_variable})]
endsnippet

snippet cfg "cfg attribute" b
#[cfg(${1:target_os = "linux"})]
endsnippet

snippet feat "feature attribute" b
#![feature(${1:plugin})]
endsnippet

snippet der "#[derive(..)]" b
#[derive(${1:Debug})]
endsnippet

snippet attr "#[..]" b
#[${1:inline}]
endsnippet

snippet crate "Define create meta attributes"
// Crate name
#![crate_name = "${1:crate_name}"]
// Additional metadata attributes
#![desc = "${2:Descrption.}"]
#![license = "${3:BSD}"]
#![comment = "${4:Comment.}"]
// Specify the output type
#![crate_type = "${5:lib}"]
endsnippet

# --> Common types

snippet opt "Option<T>"
Option<${1:i32}>
endsnippet

snippet res "Result<T, E>"
Result<${1:~str}, ${2:()}>
endsnippet

# --> Control structures

snippet if
if ${1} {
	${0}
}
endsnippet

snippet ife "if / else"
if ${1} {
	${2}
} else {
	${0}
}
endsnippet

snippet el "else"
else {
	${0}
}
endsnippet

snippet elif "else if"
else if ${1} {
	${0}
}
endsnippet

snippet match "match pattern"
match ${1} {
	${2} => ${3}
}
endsnippet

snippet case "Case clause of pattern match"
${1:_} => ${2:expression}
snippet loop "loop {}" b
loop {
	${0}
}
endsnippet

snippet wh "while loop"
while ${1:condition} {
	${0}
}
endsnippet

snippet for "for ... in ... loop"
for ${1:i} in ${2} {
	${0}
}
endsnippet

# --> TODO commenting
snippet todo "TODO comment"
// [TODO]: ${0:Description}
endsnippet

snippet fixme "FIXME comment"
// FIXME: $0
endsnippet

# --> Structs

snippet st "Struct definition"
struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
	${0}
}
endsnippet

snippet impl "Struct/Trait implementation"
impl ${1:Type/Trait}${2: for ${3:Type}} {
	${0}
}
endsnippet

snippet stn "Struct with new constructor"
pub struct ${1:`substitute(vim_snippets#Filename(), '\(_\|^\)\(.\)', '\u\2', 'g')`} {
	${0}
}

impl $1 {
	pub fn new(${2}) -> $1 {
		$1 { ${3} }
	}
}
endsnippet

snippet type "Type alias"
type ${1:NewName} = $2;
endsnippet

snippet enum "enum definition"
enum ${1:Name} {
	${2},
}
endsnippet

# --> Traits

snippet trait "Trait definition"
trait ${1:Name} {
	${0}
}
endsnippet

snippet drop "Drop trait implementation (destructor)"
impl Drop for ${1:Name} {
	fn drop(&mut self) {
		${0}
	}
}
endsnippet

# --> Statics

snippet ss "static string declaration"
static ${1}: &'static str = "${0}";
endsnippet

snippet stat "static item declaration"
static ${1}: ${2:usize} = ${0};
# Concurrency
endsnippet

snippet scoped "spawn a scoped thread"
thread::scoped(${1:move }|| {
	${0}
});
endsnippet

snippet spawn "spawn a thread"
thread::spawn(${1:move }|| {
	${0}
});
endsnippet

snippet chan "Declare (Sender, Receiver) pair of asynchronous channel()"
let (${1:tx}, ${2:rx}): (Sender<${3:i32}>, Receiver<${4:i32}>) = channel();
endsnippet

# --> Testing

snippet as "assert!"
assert!(${1:predicate})
endsnippet

snippet ase "assert_eq!"
assert_eq!(${1:expected}, ${2:actual})
endsnippet

